최종 목표
Distributed LLaMa PC(x86)/라즈베리파이 통해서 실행 후 해당 기술의 장점 / 개선할 점 찾기

현재 생각하는 장점 & 단점 (0429)

장점
1) 분산 환경이기때문에, 사용자의 환경에 크게 구애 받지않음

단점
1) 출력 방식의 문제 (수정 가능성 있으며, 이미 구현되어있을 수 있으니 구성 확인 필요)
2) 처음에 명령한 steps수를 무조건 다 사용하려고 하여, 대답이 끝난 후에도 지속적으로 다른 이야기를 진행함 (위와 동일하게 확인 필요)

주간 목표(04/29~05/03)
-워크스테이션이 아닌 2개의 노트북 환경에서 추가 실행
-출력 방식의 문제 수정
-상세한 성능 비교후 시각자료 생성



진행 상황

04/29(월)
- LLaMa 3 설치
- Distributed-LLaMa with LLaMa 2 / LLaMa 3  실행

질문 Prompt : "Please explain the distributed system."

Distributed- LLaMa 2
everybody can share the same data, the same resource, and even the same task. It is a good solution for large data or application
that needs to distribute computing power. A distributed system is a system that consists of many loosely coupled computing machines
that communicate and coordinate their actions by passing messages to one another. Distributed computing is the idea that a problem
can be split into many parts, and then the results of each part can be combined to get a solution. //103 token

A distributed system is a collection of independent computers that appear to work together as a single system. 
Distributed computing is the idea

1 token 당 평균 응답 소요시간 447.05 ms , 총합 57,222ms로 약 57초 소요되었다.
추가적으로, 반복을 제외하면 103 token 사용하였으므로 약 46초 소요되었다.

Distributed-LLaMa 3 
(1). Distributed system is a collection of networked computers (i.e. hosts) that coordinate their activities to solve a problem. 
A distributed system is a network of autonomous computers linked by communication channels that enable the computers to coordinate
their activities and to share their resources so that they can function as a coordinated whole. //71 token
(이후 반복)
1 token 당 평균 응답 소요시간 387.55 ms , 총합 49,606 ms 로 약 50초 소요되었다.
추가적으로, 반복을 제외하면 71 token 사용하였으므로 약 27.5초 소요되었다. 

LLaMa2의 답변과 LLaMa 3의 답변이 모두 정확도 측면에서 좋은 내용을 보여주였으며, 틀린 내용을 기재하지않았다.
코딩과 관련된, 더 틀리기 쉬운 내용들을 물어보아 성능 비교 추가로 진행할 예정이다.

04/30 (화)
- BK 서류작성
- 자원 사용량 분석
- 프롬프트 생성후 비교
"How can performance be optimized in Java multithreading programs? Specifically, explain how to prevent race conditions and deadlocks during parallel processing."
LLaMa2 : How can performance be optimized in Java multithreading programs specifically, 
explain how to prevent race conditions and deadlocks during parallel processing. фев 2, 2017. 
The Java Concurrency API provides a simple way to create thread pools. 
This makes the writing of thread pools much easier. java.util.concurrent.ScheduledThreadPoolExecutor; 
java.util.concurrent.ExecutorService; java.util.concurrent.ThreadPoolExecutor; java.util.concurrent.ScheduledThreadPoolExecutor; 
java.util.concurrent.ExecutorService; java.util.concurrent.ScheduledThreadPoolExecutor. 
Coding Notes: Multithreading in Java. This is the first of a new series of Coding Notes, 
where I will... 26 Jan 2017. In this tutorial, we are going to learn how to use ScheduledThreadPoolExecutor in Java. 
ScheduledThreadPoolExecutor in Java: This tutorial will... 21 May 2018. 
ScheduledThreadPoolExecutor is a subclass of ThreadPoolExecutor and it's used for scheduling tasks in a specific time interval.

LLaMa3: How can performance be optimized in Java multithreading programs? 
Specifically, explain how to prevent race conditions and deadlocks during parallel processing. 
Provide an example of how race conditions and deadlocks can occur and how they can be avoided. 
Java multithreading programs can be optimized by using the volatile keyword to ensure that variables are shared across threads and that changes made to these variables are reflected in all threads. 
This prevents race conditions, which occur when multiple threads access the same variable at the same time, and the values of that variable are not properly synchronized.
Additionally, deadlocks can occur when two or more threads are waiting for each other to complete a task, and the deadlock can only be resolved by manually breaking the cycle. 
To avoid deadlocks, use a lock manager to ensure that resources are accessed sequentially, and try to avoid blocking threads by ensuring that they can continue their tasks without waiting for other threads. 
For example, in a banking system, multiple threads might be trying to access the same account balance, which could lead to race conditions if the value is not properly synchronized. 
To prevent this, the volatile keyword can be used to ensure that the value is updated immediately, and locks can be used to ensure that only one thread accesses the account balance at a time. 
This prevents race conditions and ensures that the value is always accurate.

LLaMa2-7B는 스레딩에 대한 정보를 주지만, 정작 질문 내용을 잘 해결하지 못함.
두번째의 LLaMa3-8B는 올바른 정보를 제공.

이후 추가적으로 다른 프롬프트를 2-3개 사용해보았으나, 프롬프트에 대한 답변을 제시하지 않고,
프롬프트 내용을 그대로 출력하는 에러 발생하여 해결하려고 시도중.
자원 사용량
LLaMa2 7B 사용(384토큰) : 4335184kb(4.3GB)의 램 사용.
LLaMa3 8B 사용(384토큰) : 6285436kb(6.3GB)의 램 사용.

수요일 할 것 : LLaMa3 제대로 안뜨는 에러 해결 및 노트북환경에서의 실행, 출력 방식의 변경 시도.
